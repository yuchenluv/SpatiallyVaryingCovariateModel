#| label: MAP & MCMC
#| include: true
# MAP function
MAP_fit <- function(model, data){
optim_result = NULL
for (i in 1:25){
optim_param = optimizing(model, data = data,
seed = sample.int(.Machine$integer.max, 1),
init = "random",
check_data = TRUE, sample_file = NULL,
algorithm = c("LBFGS", "BFGS", "Newton"),
verbose = TRUE, hessian = FALSE, as_vector = TRUE,
draws = 0, constrained = TRUE,
importance_resampling = TRUE,
iter = 5000)
if (optim_param$return_code == 0){
optim_result = optim_param
break
}
}
return (optim_result)
}
# MCMC function
MCMC_fit <- function(model, data, init_list){
fit = sampling(object = model, # Stan model (compiled)
data = data, # Data as a named list
iter = 10000, chains = 4, algorithm = "NUTS",
init = list(init_list, init_list, init_list, init_list))
}
# for subsets
# index_i = index_sub1
# stations_i = stations1
# prcp_i = prcp[, index_i]
# lons_i = stations_i[, 3]
# lats_i = stations_i[, 2]
# X_i = cbind(lons_i, lats_i)
# for all data
prcp_i = prcp
lons_i = lons
lats_i = lats
X_i = X
# to exclude some years
prcp_i[112:122, ] = -99/25.4
model_full = stan_model("Spatially-Varying-Covariate-Model.stan")
data_full = list(n_station = dim(prcp_i)[2],
n_obs = n_obs,
X = X_i,
y = prcp_i,
x = log_CO2)
model_full_MAP = MAP_fit(model_full, data_full)
init_list_model_full = as.list(model_full_MAP$par)
model_full_MCMC = MCMC_fit(model_full, data_full, init_list_model_full)
file_path = "../../data/processed/1d_results/model_full_allt1_1Mruns.Rds"
saveRDS(model_full_MCMC, file_path)
model_full_MCMC
Model_full_MCMC = readRDS("../../data/processed/1d_results/model_full_allt1_1Mruns.Rds") # all stations
# Model_full_MCMC
mcmc_trace(Model_full_MCMC, pars = "logs_alpha")
#| label: load-packages
#| include: false
# Run Stan code via R:
library(rstan)
# GEV distribution
library(evd)
# Detect cores for parallelization:
options(mc.cores = parallel::detectCores())
# Useful library for plotting:
library(bayesplot)
library(ggplot2)
#| label: read raw data
#| include: false
data = read.csv("../../data/processed/raw_1d/GHCN_daily_30y.csv") # AMS data
stations = read.csv("../../data/processed/raw_1d/GHCN_stations_30y.csv") # station inventory
prcp = data[, 3:length(data)-1]
prcp[is.na(prcp)] <- -99 # change NA to negative values, could be detected in r stan
prcp = as.matrix(prcp/25.4) # mm to inches
n_station = dim(prcp)[2] # number of synthetic stations
n_obs = dim(prcp)[1] # number of years
lons = stations[, 3]
lats = stations[, 2]
X = cbind(lons, lats) # coordinates
log_CO2 = data[, length(data)] # CO2 covariate
# exculde 2000-2010
prcp[112:122, ] = -99/25.4
#| label: MAP & MCMC
#| include: true
# MAP function
MAP_fit <- function(model, data){
optim_result = NULL
for (i in 1:25){
optim_param = optimizing(model, data = data,
seed = sample.int(.Machine$integer.max, 1),
init = "random",
check_data = TRUE, sample_file = NULL,
algorithm = c("LBFGS", "BFGS", "Newton"),
verbose = TRUE, hessian = FALSE, as_vector = TRUE,
draws = 0, constrained = TRUE,
importance_resampling = TRUE,
iter = 5000)
if (optim_param$return_code == 0){
optim_result = optim_param
break
}
}
return (optim_result)
}
# MCMC function
MCMC_fit <- function(model, data, init_list){
fit = sampling(object = model, # Stan model (compiled)
data = data, # Data as a named list
iter = 10000, chains = 4, algorithm = "NUTS",
init = list(init_list, init_list, init_list, init_list))
}
model_N = stan_model("Nonpooled-Nonstationary-Model.stan")
model_N_posterior = matrix(0, nrow = 20000, nc = 5*n_station)
for (i in 1:n_station){
data_N = list(n_obs = n_obs,
y = prcp[, i],
x = log_CO2)
model_N_MAP = MAP_fit(model_N, data_N)
init_list_model_N = as.list(model_N_MAP$par)
model_N_MCMC = MCMC_fit(model_N, data_N, init_list_model_N)
model_N_posterior[ , i] = unlist(rstan::extract(model_N_MCMC, paste("mu0", sep = "")))
model_N_posterior[ , n_station+i] = unlist(rstan::extract(model_N_MCMC, paste("logs0", sep = "")))
model_N_posterior[ , n_station*2+i] = unlist(rstan::extract(model_N_MCMC, paste("xi", sep = "")))
model_N_posterior[ , n_station*3+i] = unlist(rstan::extract(model_N_MCMC, paste("mu_beta", sep = "")))
model_N_posterior[ , n_station*4+i] = unlist(rstan::extract(model_N_MCMC, paste("logs_beta", sep = "")))
}
write.csv(model_N_posterior, "../../data/processed/1d_results/model_N_t1_1M.csv")
#| label: load-packages
#| include: false
# Run Stan code via R:
library(rstan)
# GEV distribution
library(evd)
# Detect cores for parallelization:
options(mc.cores = parallel::detectCores())
# Useful library for plotting:
library(bayesplot)
library(ggplot2)
#| label: load-packages
#| include: false
# Run Stan code via R:
library(rstan)
# GEV distribution
library(evd)
# Detect cores for parallelization:
options(mc.cores = parallel::detectCores())
# Useful library for plotting:
library(bayesplot)
library(ggplot2)
#| label: load-packages
#| include: false
# Run Stan code via R:
library(rstan)
# GEV distribution
library(evd)
# Detect cores for parallelization:
options(mc.cores = parallel::detectCores())
# Useful library for plotting:
library(bayesplot)
library(ggplot2)
#| label: read raw data
#| include: false
data = read.csv("../../data/processed/raw_1d/GHCN_daily_30y.csv") # AMS data
stations = read.csv("../../data/processed/raw_1d/GHCN_stations_30y.csv") # station inventory
prcp = data[, 3:length(data)-1]
prcp[is.na(prcp)] <- -99 # change NA to negative values, could be detected in r stan
prcp = as.matrix(prcp/25.4) # mm to inches
prcp = prcp * 1.11 # change 1d to 24h observations
n_station = dim(prcp)[2] # number of synthetic stations
n_obs = dim(prcp)[1] # number of years
lons = stations[, 3]
lats = stations[, 2]
X = cbind(lons, lats) # coordinates
log_CO2 = data[, length(data)] # CO2 covariate
#| label: load-packages
#| include: false
# Run Stan code via R:
library(rstan)
# GEV distribution
library(evd)
# Detect cores for parallelization:
options(mc.cores = parallel::detectCores())
# Useful library for plotting:
library(bayesplot)
library(ggplot2)
#| label: load-packages
#| include: false
# Run Stan code via R:
library(rstan)
# GEV distribution
library(evd)
# Detect cores for parallelization:
options(mc.cores = parallel::detectCores())
# Useful library for plotting:
library(bayesplot)
library(ggplot2)
#| label: read raw data
#| include: false
data = read.csv("../../data/processed/raw_1d/GHCN_daily_30y.csv") # AMS data
stations = read.csv("../../data/processed/raw_1d/GHCN_stations_30y.csv") # station inventory
prcp = data[, 3:length(data)-1]
prcp[is.na(prcp)] <- -99 # change NA to negative values, could be detected in r stan
prcp = as.matrix(prcp/25.4) # mm to inches
prcp = prcp * 1.11 # change 1d to 24h observations
n_station = dim(prcp)[2] # number of synthetic stations
n_obs = dim(prcp)[1] # number of years
lons = stations[, 3]
lats = stations[, 2]
X = cbind(lons, lats) # coordinates
log_CO2 = data[, length(data)] # CO2 covariate
#| label: load-packages
#| include: false
# Run Stan code via R:
library(rstan)
# GEV distribution
library(evd)
# Detect cores for parallelization:
options(mc.cores = parallel::detectCores())
# Useful library for plotting:
library(bayesplot)
library(ggplot2)
#| label: read raw data
#| include: false
data = read.csv("../../data/processed/raw_1d/GHCN_daily_30y.csv") # AMS data
stations = read.csv("../../data/processed/raw_1d/GHCN_stations_30y.csv") # station inventory
prcp = data[, 3:length(data)-1]
prcp[is.na(prcp)] <- -99 # change NA to negative values, could be detected in r stan
prcp = as.matrix(prcp/25.4) # mm to inches
prcp = prcp * 1.11 # change 1d to 24h observations
n_station = dim(prcp)[2] # number of synthetic stations
n_obs = dim(prcp)[1] # number of years
lons = stations[, 3]
lats = stations[, 2]
X = cbind(lons, lats) # coordinates
log_CO2 = data[, length(data)] # CO2 covariate
#| label: MAP & MCMC
#| include: true
# MAP function
MAP_fit <- function(model, data){
optim_result = NULL
for (i in 1:25){
optim_param = optimizing(model, data = data,
seed = sample.int(.Machine$integer.max, 1),
init = "random",
check_data = TRUE, sample_file = NULL,
algorithm = c("LBFGS", "BFGS", "Newton"),
verbose = TRUE, hessian = FALSE, as_vector = TRUE,
draws = 0, constrained = TRUE,
importance_resampling = TRUE,
iter = 5000)
if (optim_param$return_code == 0){
optim_result = optim_param
break
}
}
return (optim_result)
}
# MCMC function
MCMC_fit <- function(model, data, init_list){
fit = sampling(object = model, # Stan model (compiled)
data = data, # Data as a named list
iter = 10000, chains = 4, algorithm = "NUTS",
init = list(init_list, init_list, init_list, init_list))
}
#| label: MAP & MCMC
#| include: true
# MAP function
MAP_fit <- function(model, data){
optim_result = NULL
for (i in 1:25){
optim_param = optimizing(model, data = data,
seed = sample.int(.Machine$integer.max, 1),
init = "random",
check_data = TRUE, sample_file = NULL,
algorithm = c("LBFGS", "BFGS", "Newton"),
verbose = TRUE, hessian = FALSE, as_vector = TRUE,
draws = 0, constrained = TRUE,
importance_resampling = TRUE,
iter = 5000)
if (optim_param$return_code == 0){
optim_result = optim_param
break
}
}
return (optim_result)
}
# MCMC function
MCMC_fit <- function(model, data, init_list){
fit = sampling(object = model, # Stan model (compiled)
data = data, # Data as a named list
iter = 10000, chains = 4, algorithm = "NUTS",
init = list(init_list, init_list, init_list, init_list))
}
model_N = stan_model("Nonpooled-Nonstationary-Model.stan")
model_N_posterior = matrix(0, nrow = 20000, nc = 5*n_station)
for (i in 1:n_station){
data_N = list(n_obs = n_obs,
y = prcp[, i],
x = log_CO2)
model_N_MAP = MAP_fit(model_N, data_N)
init_list_model_N = as.list(model_N_MAP$par)
model_N_MCMC = MCMC_fit(model_N, data_N, init_list_model_N)
model_N_posterior[ , i] = unlist(rstan::extract(model_N_MCMC, paste("mu0", sep = "")))
model_N_posterior[ , n_station+i] = unlist(rstan::extract(model_N_MCMC, paste("logs0", sep = "")))
model_N_posterior[ , n_station*2+i] = unlist(rstan::extract(model_N_MCMC, paste("xi", sep = "")))
model_N_posterior[ , n_station*3+i] = unlist(rstan::extract(model_N_MCMC, paste("mu_beta", sep = "")))
model_N_posterior[ , n_station*4+i] = unlist(rstan::extract(model_N_MCMC, paste("logs_beta", sep = "")))
}
write.csv(model_N_posterior, "../../data/processed/1d_results/model_N_all_10Kruns.csv")
#| label: load-packages
#| include: false
# Run Stan code via R:
library(rstan)
# GEV distribution
library(evd)
# Detect cores for parallelization:
options(mc.cores = parallel::detectCores())
# Useful library for plotting:
library(bayesplot)
library(ggplot2)
# for all data
prcp_i = prcp
lons_i = lons
lats_i = lats
X_i = X
# to exclude some years
years = data[,1]
year1_indices = seq(1, length(years), by = 2)
year2_indices = seq(2, length(years), by = 2)
prcp_i[year2_indices, ] = -99/25.4 # year1, odd years
# for all data
prcp_i = prcp
lons_i = lons
lats_i = lats
X_i = X
# to exclude some years
years = data[,1]
year1_indices = seq(1, length(years), by = 2)
year2_indices = seq(2, length(years), by = 2)
prcp_i[year2_indices, ] = -99/25.4 # year1, odd years
model_N = stan_model("Nonpooled-Nonstationary-Model.stan")
model_N_posterior = matrix(0, nrow = 20000, nc = 5*n_station)
for (i in 1:n_station){
data_N = list(n_obs = n_obs,
y = prcp_i[, i],
x = log_CO2)
model_N_MAP = MAP_fit(model_N, data_N)
init_list_model_N = as.list(model_N_MAP$par)
model_N_MCMC = MCMC_fit(model_N, data_N, init_list_model_N)
model_N_posterior[ , i] = unlist(rstan::extract(model_N_MCMC, paste("mu0", sep = "")))
model_N_posterior[ , n_station+i] = unlist(rstan::extract(model_N_MCMC, paste("logs0", sep = "")))
model_N_posterior[ , n_station*2+i] = unlist(rstan::extract(model_N_MCMC, paste("xi", sep = "")))
model_N_posterior[ , n_station*3+i] = unlist(rstan::extract(model_N_MCMC, paste("mu_beta", sep = "")))
model_N_posterior[ , n_station*4+i] = unlist(rstan::extract(model_N_MCMC, paste("logs_beta", sep = "")))
}
write.csv(model_N_posterior, "../../data/processed/1d_results/model_N_y1_10Kruns.csv")
# for all data
prcp_i = prcp
lons_i = lons
lats_i = lats
X_i = X
# to exclude some years
years = data[,1]
year1_indices = seq(1, length(years), by = 2)
year2_indices = seq(2, length(years), by = 2)
prcp_i[year1_indices, ] = -99/25.4 # year2, even years
model_N = stan_model("Nonpooled-Nonstationary-Model.stan")
model_N_posterior = matrix(0, nrow = 20000, nc = 5*n_station)
for (i in 1:n_station){
data_N = list(n_obs = n_obs,
y = prcp_i[, i],
x = log_CO2)
model_N_MAP = MAP_fit(model_N, data_N)
init_list_model_N = as.list(model_N_MAP$par)
model_N_MCMC = MCMC_fit(model_N, data_N, init_list_model_N)
model_N_posterior[ , i] = unlist(rstan::extract(model_N_MCMC, paste("mu0", sep = "")))
model_N_posterior[ , n_station+i] = unlist(rstan::extract(model_N_MCMC, paste("logs0", sep = "")))
model_N_posterior[ , n_station*2+i] = unlist(rstan::extract(model_N_MCMC, paste("xi", sep = "")))
model_N_posterior[ , n_station*3+i] = unlist(rstan::extract(model_N_MCMC, paste("mu_beta", sep = "")))
model_N_posterior[ , n_station*4+i] = unlist(rstan::extract(model_N_MCMC, paste("logs_beta", sep = "")))
}
write.csv(model_N_posterior, "../../data/processed/1d_results/model_N_y2_10Kruns.csv")
2.237 * 0.44704
#| label: load-packages
#| include: false
# Run Stan code via R:
library(rstan)
# GEV distribution
library(evd)
# Detect cores for parallelization:
options(mc.cores = parallel::detectCores())
# Useful library for plotting:
library(bayesplot)
library(ggplot2)
#| label: read raw data
#| include: false
data = read.csv("../../data/processed/raw_1d/GHCN_daily_30y.csv") # AMS data
stations = read.csv("../../data/processed/raw_1d/GHCN_stations_30y.csv") # station inventory
prcp = data[, 3:length(data)-1]
prcp[is.na(prcp)] <- -99 # change NA to negative values, could be detected in r stan
prcp = as.matrix(prcp/25.4) # mm to inches
prcp = prcp * 1.11 # change 1d to 24h observations
n_station = dim(prcp)[2] # number of synthetic stations
n_obs = dim(prcp)[1] # number of years
lons = stations[, 3]
lats = stations[, 2]
X = cbind(lons, lats) # coordinates
log_CO2 = data[, length(data)] # CO2 covariate
#| label: MAP & MCMC
#| include: true
# MAP function
MAP_fit <- function(model, data){
optim_result = NULL
for (i in 1:25){
optim_param = optimizing(model, data = data,
seed = sample.int(.Machine$integer.max, 1),
init = "random",
check_data = TRUE, sample_file = NULL,
algorithm = c("LBFGS", "BFGS", "Newton"),
verbose = TRUE, hessian = FALSE, as_vector = TRUE,
draws = 0, constrained = TRUE,
importance_resampling = TRUE,
iter = 5000)
if (optim_param$return_code == 0){
optim_result = optim_param
break
}
}
return (optim_result)
}
# MCMC function
MCMC_fit <- function(model, data, init_list){
fit = sampling(object = model, # Stan model (compiled)
data = data, # Data as a named list
iter = 10000, chains = 4, algorithm = "NUTS",
init = list(init_list, init_list, init_list, init_list))
}
# for all data
prcp_i = prcp
lons_i = lons
lats_i = lats
X_i = X
# to exclude some years
# years = data[,1]
# year1_indices = seq(1, length(years), by = 2)
# year2_indices = seq(2, length(years), by = 2)
# prcp_i[year1_indices, ] = -99/25.4 # year2, even years
# for all data
prcp_i = prcp
lons_i = lons
lats_i = lats
X_i = X
# to exclude some years
# years = data[,1]
# year1_indices = seq(1, length(years), by = 2)
# year2_indices = seq(2, length(years), by = 2)
# prcp_i[year1_indices, ] = -99/25.4 # year2, even years
model_S = stan_model("Pooled-Stationary-Model.stan")
data_S = list(n_station = dim(prcp_i)[2],
n_obs = n_obs,
X = X,
y = prcp)
model_S_MAP = MAP_fit(model_S, data_S)
init_list_model_S = as.list(model_S_MAP$par)
model_S_MCMC = MCMC_fit(model_S, data_S, init_list_model_S)
file_path = "../../data/processed/1d_results/model_S_all_10Kruns.Rds"
saveRDS(model_S_MCMC, file_path)
model_S_MCMC
# for all data
prcp_i = prcp
lons_i = lons
lats_i = lats
X_i = X
# to exclude some years
years = data[,1]
year1_indices = seq(1, length(years), by = 2)
year2_indices = seq(2, length(years), by = 2)
prcp_i[year2_indices, ] = -99/25.4 # year1, even years
model_S = stan_model("Pooled-Stationary-Model.stan")
data_S = list(n_station = dim(prcp_i)[2],
n_obs = n_obs,
X = X,
y = prcp)
model_S_MAP = MAP_fit(model_S, data_S)
init_list_model_S = as.list(model_S_MAP$par)
model_S_MCMC = MCMC_fit(model_S, data_S, init_list_model_S)
file_path = "../../data/processed/1d_results/model_S_y1_10Kruns.Rds"
saveRDS(model_S_MCMC, file_path)
model_S_MCMC
# for all data
prcp_i = prcp
lons_i = lons
lats_i = lats
X_i = X
# to exclude some years
years = data[,1]
year1_indices = seq(1, length(years), by = 2)
year2_indices = seq(2, length(years), by = 2)
prcp_i[year1_indices, ] = -99/25.4 # year2, even years
model_S = stan_model("Pooled-Stationary-Model.stan")
data_S = list(n_station = dim(prcp_i)[2],
n_obs = n_obs,
X = X,
y = prcp)
model_S_MAP = MAP_fit(model_S, data_S)
init_list_model_S = as.list(model_S_MAP$par)
model_S_MCMC = MCMC_fit(model_S, data_S, init_list_model_S)
file_path = "../../data/processed/1d_results/model_S_y2_10Kruns.Rds"
saveRDS(model_S_MCMC, file_path)
model_S_MCMC
