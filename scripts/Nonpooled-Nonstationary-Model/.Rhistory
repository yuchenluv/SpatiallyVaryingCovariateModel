#| label: load-packages
#| include: false
# Run Stan code via R:
library(rstan)
# GEV distribution
library(evd)
# Detect cores for parallelization:
options(mc.cores = parallel::detectCores())
# Useful library for plotting:
library(bayesplot)
library(ggplot2)
#| label: read raw data
#| include: false
data = read.csv("../../data/processed/raw_1d/GHCN_daily_30y.csv") # AMS data
stations = read.csv("../../data/processed/raw_1d/GHCN_stations_30y.csv") # station inventory
prcp = data[, 3:length(data)-1]
prcp[is.na(prcp)] <- -99 # change NA to negative values, could be detected in r stan
prcp = as.matrix(prcp/25.4) # mm to inches
n_station = dim(prcp)[2] # number of synthetic stations
n_obs = dim(prcp)[1] # number of years
lons = stations[, 3]
lats = stations[, 2]
X = cbind(lons, lats) # coordinates
log_CO2 = data[, length(data)] # CO2 covariate
lats_grids = c(max(lats), 30.5, 30, 29.5, 29, min(lats))
lons_grids = c(min(lons), -94.9, -92.8, -90.7, -88.6, max(lons))
# plot the subsets
plot(x = lons, y = lats, pch = 19)
abline(v = lons_grids[2])
abline(v = lons_grids[3])
abline(v = lons_grids[4])
abline(v = lons_grids[5])
abline(h = lats_grids[2])
abline(h = lats_grids[3])
abline(h = lats_grids[4])
abline(h = lats_grids[5])
# subset 1
stations1 = stations[!((stations$lon >= lons_grids[1] & stations$lon <= lons_grids[2] & stations$lat >= lats_grids[2] & stations$lat <= lats_grids[1]) | (stations$lon >= lons_grids[2] & stations$lon <= lons_grids[3] & stations$lat >= lats_grids[3] & stations$lat <= lats_grids[2]) | (stations$lon >= lons_grids[3] & stations$lon <= lons_grids[4] & stations$lat >= lats_grids[4] & stations$lat <= lats_grids[3]) | (stations$lon >= lons_grids[4] & stations$lon <= lons_grids[5] & stations$lat >= lats_grids[5] & stations$lat <= lats_grids[4]) | (stations$lon >= lons_grids[5] & stations$lon <= lons_grids[6] & stations$lat >= lats_grids[6] & stations$lat <= lats_grids[5])), ]
index_sub1 = which(stations$stnid %in% stations1[,1])
write.csv(index_sub1, file = "../../data/processed/1d_results/sub1_index.csv", row.names = FALSE)
# subset 2
stations2 = stations[!((stations$lon >= lons_grids[2] & stations$lon <= lons_grids[3] & stations$lat >= lats_grids[2] & stations$lat <= lats_grids[1]) | (stations$lon >= lons_grids[3] & stations$lon <= lons_grids[4] & stations$lat >= lats_grids[3] & stations$lat <= lats_grids[2]) | (stations$lon >= lons_grids[4] & stations$lon <= lons_grids[5] & stations$lat >= lats_grids[4] & stations$lat <= lats_grids[3]) | (stations$lon >= lons_grids[5] & stations$lon <= lons_grids[6] & stations$lat >= lats_grids[5] & stations$lat <= lats_grids[4]) | (stations$lon >= lons_grids[1] & stations$lon <= lons_grids[2] & stations$lat >= lats_grids[6] & stations$lat <= lats_grids[5])), ]
index_sub2 = which(stations$stnid %in% stations2[,1])
write.csv(index_sub2, file = "../../data/processed/1d_results/sub2_index.csv", row.names = FALSE)
# subset 3
stations3 = stations[!((stations$lon >= lons_grids[3] & stations$lon <= lons_grids[4] & stations$lat >= lats_grids[2] & stations$lat <= lats_grids[1]) | (stations$lon >= lons_grids[4] & stations$lon <= lons_grids[5] & stations$lat >= lats_grids[3] & stations$lat <= lats_grids[2]) | (stations$lon >= lons_grids[5] & stations$lon <= lons_grids[6] & stations$lat >= lats_grids[4] & stations$lat <= lats_grids[3]) | (stations$lon >= lons_grids[1] & stations$lon <= lons_grids[2] & stations$lat >= lats_grids[5] & stations$lat <= lats_grids[4]) | (stations$lon >= lons_grids[2] & stations$lon <= lons_grids[3] & stations$lat >= lats_grids[6] & stations$lat <= lats_grids[5])), ]
index_sub3 = which(stations$stnid %in% stations3[,1])
write.csv(index_sub3, file = "../../data/processed/1d_results/sub3_index.csv", row.names = FALSE)
# subset 4
stations4 = stations[!((stations$lon >= lons_grids[4] & stations$lon <= lons_grids[5] & stations$lat >= lats_grids[2] & stations$lat <= lats_grids[1]) | (stations$lon >= lons_grids[5] & stations$lon <= lons_grids[6] & stations$lat >= lats_grids[3] & stations$lat <= lats_grids[2]) | (stations$lon >= lons_grids[1] & stations$lon <= lons_grids[2] & stations$lat >= lats_grids[4] & stations$lat <= lats_grids[3]) | (stations$lon >= lons_grids[2] & stations$lon <= lons_grids[3] & stations$lat >= lats_grids[5] & stations$lat <= lats_grids[4]) | (stations$lon >= lons_grids[3] & stations$lon <= lons_grids[4] & stations$lat >= lats_grids[6] & stations$lat <= lats_grids[5])), ]
index_sub4 = which(stations$stnid %in% stations4[,1])
write.csv(index_sub4, file = "../../data/processed/1d_results/sub4_index.csv", row.names = FALSE)
# subset 5
stations5 = stations[!((stations$lon >= lons_grids[5] & stations$lon <= lons_grids[6] & stations$lat >= lats_grids[2] & stations$lat <= lats_grids[1]) | (stations$lon >= lons_grids[1] & stations$lon <= lons_grids[2] & stations$lat >= lats_grids[3] & stations$lat <= lats_grids[2]) | (stations$lon >= lons_grids[2] & stations$lon <= lons_grids[3] & stations$lat >= lats_grids[4] & stations$lat <= lats_grids[3]) | (stations$lon >= lons_grids[3] & stations$lon <= lons_grids[4] & stations$lat >= lats_grids[5] & stations$lat <= lats_grids[4]) | (stations$lon >= lons_grids[4] & stations$lon <= lons_grids[5] & stations$lat >= lats_grids[6] & stations$lat <= lats_grids[5])), ]
index_sub5 = which(stations$stnid %in% stations5[,1])
write.csv(index_sub5, file = "../../data/processed/1d_results/sub5_index.csv", row.names = FALSE)
#| label: MAP & MCMC
#| include: true
# MAP function
MAP_fit <- function(model, data){
optim_result = NULL
for (i in 1:25){
optim_param = optimizing(model, data = data,
seed = sample.int(.Machine$integer.max, 1),
init = "random",
check_data = TRUE, sample_file = NULL,
algorithm = c("LBFGS", "BFGS", "Newton"),
verbose = TRUE, hessian = FALSE, as_vector = TRUE,
draws = 0, constrained = TRUE,
importance_resampling = TRUE,
iter = 5000)
if (optim_param$return_code == 0){
optim_result = optim_param
break
}
}
return (optim_result)
}
# MCMC function
MCMC_fit <- function(model, data, init_list){
fit = sampling(object = model, # Stan model (compiled)
data = data, # Data as a named list
iter = 10000, chains = 4, algorithm = "NUTS",
init = list(init_list, init_list, init_list, init_list))
}
# for subsets
# index_i = index_sub1
# stations_i = stations1
# prcp_i = prcp[, index_i]
# lons_i = stations_i[, 3]
# lats_i = stations_i[, 2]
# X_i = cbind(lons_i, lats_i)
# for all data
prcp_i = prcp
lons_i = lons
lats_i = lats
X_i = X
# to exclude some years
prcp_i[112:122, ] = -99/25.4
model_full = stan_model("Spatially-Varying-Covariate-Model.stan")
data_full = list(n_station = dim(prcp_i)[2],
n_obs = n_obs,
X = X_i,
y = prcp_i,
x = log_CO2)
model_full_MAP = MAP_fit(model_full, data_full)
init_list_model_full = as.list(model_full_MAP$par)
model_full_MCMC = MCMC_fit(model_full, data_full, init_list_model_full)
file_path = "../../data/processed/1d_results/model_full_allt1_1Mruns.Rds"
saveRDS(model_full_MCMC, file_path)
model_full_MCMC
Model_full_MCMC = readRDS("../../data/processed/1d_results/model_full_allt1_1Mruns.Rds") # all stations
# Model_full_MCMC
mcmc_trace(Model_full_MCMC, pars = "logs_alpha")
#| label: load-packages
#| include: false
# Run Stan code via R:
library(rstan)
# GEV distribution
library(evd)
# Detect cores for parallelization:
options(mc.cores = parallel::detectCores())
# Useful library for plotting:
library(bayesplot)
library(ggplot2)
#| label: read raw data
#| include: false
data = read.csv("../../data/processed/raw_1d/GHCN_daily_30y.csv") # AMS data
stations = read.csv("../../data/processed/raw_1d/GHCN_stations_30y.csv") # station inventory
prcp = data[, 3:length(data)-1]
prcp[is.na(prcp)] <- -99 # change NA to negative values, could be detected in r stan
prcp = as.matrix(prcp/25.4) # mm to inches
n_station = dim(prcp)[2] # number of synthetic stations
n_obs = dim(prcp)[1] # number of years
lons = stations[, 3]
lats = stations[, 2]
X = cbind(lons, lats) # coordinates
log_CO2 = data[, length(data)] # CO2 covariate
# exculde 2000-2010
prcp[112:122, ] = -99/25.4
#| label: MAP & MCMC
#| include: true
# MAP function
MAP_fit <- function(model, data){
optim_result = NULL
for (i in 1:25){
optim_param = optimizing(model, data = data,
seed = sample.int(.Machine$integer.max, 1),
init = "random",
check_data = TRUE, sample_file = NULL,
algorithm = c("LBFGS", "BFGS", "Newton"),
verbose = TRUE, hessian = FALSE, as_vector = TRUE,
draws = 0, constrained = TRUE,
importance_resampling = TRUE,
iter = 5000)
if (optim_param$return_code == 0){
optim_result = optim_param
break
}
}
return (optim_result)
}
# MCMC function
MCMC_fit <- function(model, data, init_list){
fit = sampling(object = model, # Stan model (compiled)
data = data, # Data as a named list
iter = 10000, chains = 4, algorithm = "NUTS",
init = list(init_list, init_list, init_list, init_list))
}
model_N = stan_model("Nonpooled-Nonstationary-Model.stan")
model_N_posterior = matrix(0, nrow = 20000, nc = 5*n_station)
for (i in 1:n_station){
data_N = list(n_obs = n_obs,
y = prcp[, i],
x = log_CO2)
model_N_MAP = MAP_fit(model_N, data_N)
init_list_model_N = as.list(model_N_MAP$par)
model_N_MCMC = MCMC_fit(model_N, data_N, init_list_model_N)
model_N_posterior[ , i] = unlist(rstan::extract(model_N_MCMC, paste("mu0", sep = "")))
model_N_posterior[ , n_station+i] = unlist(rstan::extract(model_N_MCMC, paste("logs0", sep = "")))
model_N_posterior[ , n_station*2+i] = unlist(rstan::extract(model_N_MCMC, paste("xi", sep = "")))
model_N_posterior[ , n_station*3+i] = unlist(rstan::extract(model_N_MCMC, paste("mu_beta", sep = "")))
model_N_posterior[ , n_station*4+i] = unlist(rstan::extract(model_N_MCMC, paste("logs_beta", sep = "")))
}
write.csv(model_N_posterior, "../../data/processed/1d_results/model_N_t1_1M.csv")
