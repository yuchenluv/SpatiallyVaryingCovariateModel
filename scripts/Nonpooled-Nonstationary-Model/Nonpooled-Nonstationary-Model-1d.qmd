---
title: "Nonpooled Nonstationary Model"
format: html
---

Load the necessary packages

```{r}
#| label: load-packages
#| include: false

# Run Stan code via R:
library(rstan)

# GEV distribution
library(evd)

# Detect cores for parallelization:
options(mc.cores = parallel::detectCores())

# Useful library for plotting:
library(bayesplot)
library(ggplot2)
```

Read precipitation and climate covariate data

```{r}
#| label: read raw data
#| include: false
data = read.csv("../../data/processed/raw_1d/GHCN_daily_30y.csv") # AMS data
stations = read.csv("../../data/processed/raw_1d/GHCN_stations_30y.csv") # station inventory

prcp = data[, 3:length(data)-1]
prcp[is.na(prcp)] <- -99 # change NA to negative values, could be detected in r stan
prcp = as.matrix(prcp/25.4) # mm to inches

n_station = dim(prcp)[2] # number of synthetic stations
n_obs = dim(prcp)[1] # number of years
lons = stations[, 3]
lats = stations[, 2]
X = cbind(lons, lats) # coordinates

log_CO2 = data[, length(data)] # CO2 covariate
```

```{r}
lats_grids = c(min(lats), 29, 29.5, 30, 30.5, max(lats))
lons_grids = c(min(lons), -94.9, -92.8, -90.7, -88.6, max(lons))

stations1 = stations[!((stations$lon >= lons_grids[1] & stations$lon <= lons_grids[2] & stations$lat >= lats_grids[1] & stations$lat <= lats_grids[2]) | (stations$lon >= lons_grids[2] & stations$lon <= lons_grids[3] & stations$lat >= lats_grids[2] & stations$lat <= lats_grids[3]) | (stations$lon >= lons_grids[3] & stations$lon <= lons_grids[4] & stations$lat >= lats_grids[3] & stations$lat <= lats_grids[4])) | (stations$lon >= lons_grids[4] & stations$lon <= lons_grids[5] & stations$lat >= lats_grids[4] & stations$lat <= lats_grids[5]) | (stations$lon >= lons_grids[5] & stations$lon <= lons_grids[6] & stations$lat >= lats_grids[5] & stations$lat <= lats_grids[6]), ]

index_sub1 = which(stations$stnid %in% stations1[,1])
prcp1 = prcp_shuffled[, index_sub1]
lons1 = stations1[, 3]
lats1 = stations1[, 2]
X1 = cbind(lons1, lats1)
prcp1[112:122, ] = -99/25.4

write.csv(index_sub1, file = "../../data/processed/1d_results/sub1_index.csv", row.names = FALSE)
```

```{r}
plot(x = lons, y = lats, pch = 19)
abline(v = lons_grids[2])
abline(v = lons_grids[3])
abline(v = lons_grids[4])
abline(v = lons_grids[5])

abline(h = lats_grids[2])
abline(h = lats_grids[3])
abline(h = lats_grids[4])
abline(h = lats_grids[5])
```

Shuffle stations to create subsets for cross-validation

```{r}
# random shuffle the station inventory
set.seed(42)
sequence = sample(nrow(stations))
stations_shuffled = stations[sequence, ]
prcp_shuffled = prcp[, sequence]
# 36, 36, 36, 36, 37
```

Functions for MAP and MCMC simulations

```{r}
#| label: MAP & MCMC
#| include: true

# MAP function
MAP_fit <- function(model, data){
  optim_result = NULL
  for (i in 1:25){
    optim_param = optimizing(model, data = data,
                             seed = sample.int(.Machine$integer.max, 1), 
                             init = "random",
                             check_data = TRUE, sample_file = NULL,
                             algorithm = c("LBFGS", "BFGS", "Newton"),
                             verbose = TRUE, hessian = FALSE, as_vector = TRUE,
                             draws = 0, constrained = TRUE, 
                             importance_resampling = TRUE, 
                             iter = 5000)
    if (optim_param$return_code == 0){
      optim_result = optim_param
      break
    }
  }
  return (optim_result)
}

# MCMC function
MCMC_fit <- function(model, data, init_list){
  fit = sampling(object = model, # Stan model (compiled)
                 data = data, # Data as a named list
                 iter = 5000, chains = 4, algorithm = "NUTS", 
                 init = list(init_list, init_list, init_list, init_list))
}
```

MAP and MCMC runs (5000 iterations 4 chains)

```{r}
model_N = stan_model("Nonpooled-Nonstationary-Model.stan")
model_N_posterior = matrix(0, nrow = 10000, nc = 5*n_station)
for (i in 1:n_station){
  prcp_i = prcp_shuffled[, i]
  data_N = list(n_obs = n_obs,
                y = prcp_i,
                x = log_CO2)
  
  model_N_MAP = MAP_fit(model_N, data_N)
  init_list_model_N = as.list(model_N_MAP$par)
  model_N_MCMC = MCMC_fit(model_N, data_N, init_list_model_N)
  
  model_N_posterior[ , i] = unlist(rstan::extract(model_N_MCMC, paste("mu0", sep = "")))
  model_N_posterior[ , n_station+i] = unlist(rstan::extract(model_N_MCMC, paste("logs0", sep = "")))
  model_N_posterior[ , n_station*2+i] = unlist(rstan::extract(model_N_MCMC, paste("xi", sep = "")))
  model_N_posterior[ , n_station*3+i] = unlist(rstan::extract(model_N_MCMC, paste("mu_beta", sep = "")))
  model_N_posterior[ , n_station*4+i] = unlist(rstan::extract(model_N_MCMC, paste("logs_beta", sep = "")))
}
```

```{r}
write.csv(model_N_posterior, "../../data/processed/1d_results/model_N_posterior.csv")
```
