---
title: "Nonpooled Nonstationary Model"
format: html
---

Load the necessary packages

```{r}
#| label: load-packages
#| include: false

# Run Stan code via R:
library(rstan)

# GEV distribution
library(evd)

# Detect cores for parallelization:
options(mc.cores = parallel::detectCores())

# Useful library for plotting:
library(bayesplot)
library(ggplot2)
```

Read precipitation and climate covariate data

```{r}
#| label: read raw data
#| include: false
data = read.csv("../../data/processed/raw_1d/GHCN_daily_30y.csv") # AMS data
stations = read.csv("../../data/processed/raw_1d/GHCN_stations_30y.csv") # station inventory

prcp = data[, 3:length(data)-1]
prcp[is.na(prcp)] <- -99 # change NA to negative values, could be detected in r stan
prcp = as.matrix(prcp/25.4) # mm to inches
prcp = prcp * 1.11 # change 1d to 24h observations

n_station = dim(prcp)[2] # number of synthetic stations
n_obs = dim(prcp)[1] # number of years
lons = stations[, 3]
lats = stations[, 2]
X = cbind(lons, lats) # coordinates

log_CO2 = data[, length(data)] # CO2 covariate
```

Functions for MAP and MCMC simulations

```{r}
#| label: MAP & MCMC
#| include: true

# MAP function
MAP_fit <- function(model, data){
  optim_result = NULL
  for (i in 1:25){
    optim_param = optimizing(model, data = data,
                             seed = sample.int(.Machine$integer.max, 1), 
                             init = "random",
                             check_data = TRUE, sample_file = NULL,
                             algorithm = c("LBFGS", "BFGS", "Newton"),
                             verbose = TRUE, hessian = FALSE, as_vector = TRUE,
                             draws = 0, constrained = TRUE, 
                             importance_resampling = TRUE, 
                             iter = 5000)
    if (optim_param$return_code == 0){
      optim_result = optim_param
      break
    }
  }
  return (optim_result)
}

# MCMC function
MCMC_fit <- function(model, data, init_list){
  fit = sampling(object = model, # Stan model (compiled)
                 data = data, # Data as a named list
                 iter = 10000, chains = 4, algorithm = "NUTS", 
                 init = list(init_list, init_list, init_list, init_list))
}
```

MAP and MCMC runs (5000 iterations 4 chains)

Define the dataset for simulations

```{r}
# for all data
prcp_i = prcp
lons_i = lons
lats_i = lats
X_i = X

# to exclude some years
years = data[,1]
year1_indices = seq(1, length(years), by = 2)
year2_indices = seq(2, length(years), by = 2)
prcp_i[year1_indices, ] = -99/25.4 # year2, even years
```

```{r}
model_N = stan_model("Nonpooled-Nonstationary-Model.stan")
model_N_posterior = matrix(0, nrow = 20000, nc = 5*n_station)
for (i in 1:n_station){
  data_N = list(n_obs = n_obs,
                y = prcp_i[, i],
                x = log_CO2)
  print(i)
  
  model_N_MAP = MAP_fit(model_N, data_N)
  init_list_model_N = as.list(model_N_MAP$par)
  model_N_MCMC = MCMC_fit(model_N, data_N, init_list_model_N)
  print(model_N_MCMC)
  
  model_N_posterior[ , i] = unlist(rstan::extract(model_N_MCMC, paste("mu0", sep = "")))
  model_N_posterior[ , n_station+i] = unlist(rstan::extract(model_N_MCMC, paste("logs0", sep = "")))
  model_N_posterior[ , n_station*2+i] = unlist(rstan::extract(model_N_MCMC, paste("xi", sep = "")))
  model_N_posterior[ , n_station*3+i] = unlist(rstan::extract(model_N_MCMC, paste("mu_beta", sep = "")))
  model_N_posterior[ , n_station*4+i] = unlist(rstan::extract(model_N_MCMC, paste("logs_beta", sep = "")))
}
```

```{r}
write.csv(model_N_posterior, "../../data/processed/1d_results/model_N_y2_10Kruns.csv")
```
