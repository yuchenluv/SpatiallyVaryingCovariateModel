---
title: "Pooled Stationary Model"
format: html
---

Load the necessary packages

```{r}
#| label: load-packages
#| include: false

# Run Stan code via R:
library(rstan)

# GEV distribution
library(evd)

# Detect cores for parallelization:
options(mc.cores = parallel::detectCores())

# Useful library for plotting:
library(bayesplot)
library(ggplot2)
```

Read precipitation and climate covariate data

```{r}
#| label: read raw data
#| include: false
data = read.csv("../../data/processed/raw_1d/GHCN_daily_30y.csv") # AMS data
stations = read.csv("../../data/processed/raw_1d/GHCN_stations_30y.csv") # station inventory

prcp = data[, 3:length(data)-1]
prcp[is.na(prcp)] <- -99 # change NA to negative values, could be detected in r stan
prcp = as.matrix(prcp/25.4) # mm to inches

n_station = dim(prcp)[2] # number of synthetic stations
n_obs = dim(prcp)[1] # number of years
lons = stations[, 3]
lats = stations[, 2]
X = cbind(lons, lats) # coordinates

log_CO2 = data[, length(data)] # CO2 covariate

# exculde 2000-2010
prcp_t1 = prcp
prcp_t1[112:122, ] = -99/25.4
```

Functions for MAP and MCMC simulations

```{r}
#| label: MAP & MCMC
#| include: true

# MAP function
MAP_fit <- function(model, data){
  optim_result = NULL
  for (i in 1:25){
    optim_param = optimizing(model, data = data,
                             seed = sample.int(.Machine$integer.max, 1), 
                             init = "random",
                             check_data = TRUE, sample_file = NULL,
                             algorithm = c("LBFGS", "BFGS", "Newton"),
                             verbose = TRUE, hessian = FALSE, as_vector = TRUE,
                             draws = 0, constrained = TRUE, 
                             importance_resampling = TRUE, 
                             iter = 5000)
    if (optim_param$return_code == 0){
      optim_result = optim_param
      break
    }
  }
  return (optim_result)
}

# MCMC function
MCMC_fit <- function(model, data, init_list){
  fit = sampling(object = model, # Stan model (compiled)
                 data = data, # Data as a named list
                 iter = 5000, chains = 4, algorithm = "NUTS", 
                 init = list(init_list, init_list, init_list, init_list))
}
```

MAP and MCMC runs (5000 iterations 4 chains)

```{r}
model_S = stan_model("Pooled-Stationary-Model.stan")
data_S = list(n_station = dim(prcp)[2],
              n_obs = n_obs,
              X = X,
              y = prcp_t1)
model_S_MAP = MAP_fit(model_S, data_S)
init_list_model_S = as.list(model_S_MAP$par)
model_S_MCMC = MCMC_fit(model_S, data_S, init_list_model_S)
  
file_path = "../../data/processed/1d_results/model_S_t1.Rds"
saveRDS(model_S_MCMC, file_path)
model_S_MCMC
```

Load previous results (if MCMC was done before)

```{r}
# model_S_MCMC = readRDS("../../data/processed/1d_results/model_S_all.Rds")
model_S_MCMC
```

Export MCMC results to be plotted in Julia

```{r}
extract_MCMC <- function(MCMC_posterior_all, variable, station_i){
  return (unlist(rstan::extract(MCMC_posterior_all, paste(variable, "[", station_i, "]", sep = ""))))
}
```

```{r}
variables_S = c("mu_rho", "mu_alpha", "logs_rho", "logs_alpha", "xi")
n_s = n_station
model_S_MCMC_i = readRDS("../../data/processed/1d_results/model_S_t1.Rds")
model_S_posterior = matrix(0, nrow = 10000, nc = 5+2*n_s)

for (v in 1:length(variables_S)){
  model_S_posterior[ , v] = unlist(rstan::extract(model_S_MCMC_i, paste(variables_S[v], sep = "")))
}
for (s in 1:n_s){
  model_S_posterior[ , length(variables_S)+s] = extract_MCMC(model_S_MCMC_i, "mu", s)
}
for (s in 1:n_s){
  model_S_posterior[ , length(variables_S)+n_s+s] = extract_MCMC(model_S_MCMC_i, "logs", s)
}
model_S_posterior = as.data.frame(model_S_posterior)
file_path = "../../data/processed/1d_results/model_S_t1.csv"
write.csv(model_S_posterior, file_path)
```
