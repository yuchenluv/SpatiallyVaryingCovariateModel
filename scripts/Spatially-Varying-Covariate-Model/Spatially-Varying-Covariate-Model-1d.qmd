---
title: "Spatially Varying Covariate Model"
format: html
---

Load the packages

```{r}
#| label: load-packages
#| include: false

# Run Stan code via R:
library(rstan)

# GEV distribution
library(evd)

# Detect cores for parallelization:
options(mc.cores = parallel::detectCores())

# Useful library for plotting:
library(bayesplot)
library(ggplot2)
```

Read precipitation and climate covariate data

```{r}
#| label: read raw data
#| include: false
data = read.csv("../../data/processed/raw_1d/GHCN_daily_30y.csv") # AMS data
stations = read.csv("../../data/processed/raw_1d/GHCN_stations_30y.csv") # station inventory

prcp = data[, 3:length(data)-1]
prcp[is.na(prcp)] <- -99 # change NA to negative values, could be detected in r stan
prcp = as.matrix(prcp/25.4) # mm to inches

n_station = dim(prcp)[2] # number of synthetic stations
n_obs = dim(prcp)[1] # number of years
lons = stations[, 3]
lats = stations[, 2]
X = cbind(lons, lats) # coordinates

log_CO2 = data[, length(data)] # CO2 covariate
```

Subset the stations

```{r}
lats_grids = c(min(lats), 29, 29.5, 30, 30.5, max(lats))
lons_grids = c(min(lons), -94.9, -92.8, -90.7, -88.6, max(lons))

# plot the subsets
plot(x = lons, y = lats, pch = 19)
abline(v = lons_grids[2])
abline(v = lons_grids[3])
abline(v = lons_grids[4])
abline(v = lons_grids[5])

abline(h = lats_grids[2])
abline(h = lats_grids[3])
abline(h = lats_grids[4])
abline(h = lats_grids[5])
```

```{r}
# subset 1
stations1 = stations[!((stations$lon >= lons_grids[1] & stations$lon <= lons_grids[2] & stations$lat >= lats_grids[1] & stations$lat <= lats_grids[2]) | (stations$lon >= lons_grids[2] & stations$lon <= lons_grids[3] & stations$lat >= lats_grids[2] & stations$lat <= lats_grids[3]) | (stations$lon >= lons_grids[3] & stations$lon <= lons_grids[4] & stations$lat >= lats_grids[3] & stations$lat <= lats_grids[4])) | (stations$lon >= lons_grids[4] & stations$lon <= lons_grids[5] & stations$lat >= lats_grids[4] & stations$lat <= lats_grids[5]) | (stations$lon >= lons_grids[5] & stations$lon <= lons_grids[6] & stations$lat >= lats_grids[5] & stations$lat <= lats_grids[6]), ]

index_sub1 = which(stations$stnid %in% stations1[,1])
write.csv(index_sub1, file = "../../data/processed/1d_results/sub1_index.csv", row.names = FALSE)

# subset 2
stations2 = stations[!((stations$lon >= lons_grids[2] & stations$lon <= lons_grids[3] & stations$lat >= lats_grids[1] & stations$lat <= lats_grids[2]) | (stations$lon >= lons_grids[3] & stations$lon <= lons_grids[4] & stations$lat >= lats_grids[2] & stations$lat <= lats_grids[3]) | (stations$lon >= lons_grids[4] & stations$lon <= lons_grids[5] & stations$lat >= lats_grids[3] & stations$lat <= lats_grids[4])) | (stations$lon >= lons_grids[5] & stations$lon <= lons_grids[6] & stations$lat >= lats_grids[4] & stations$lat <= lats_grids[5]) | (stations$lon >= lons_grids[1] & stations$lon <= lons_grids[2] & stations$lat >= lats_grids[5] & stations$lat <= lats_grids[6]), ]

index_sub2 = which(stations$stnid %in% stations2[,1])
write.csv(index_sub2, file = "../../data/processed/1d_results/sub2_index.csv", row.names = FALSE)

# subset 3
stations3 = stations[!((stations$lon >= lons_grids[3] & stations$lon <= lons_grids[4] & stations$lat >= lats_grids[1] & stations$lat <= lats_grids[2]) | (stations$lon >= lons_grids[4] & stations$lon <= lons_grids[5] & stations$lat >= lats_grids[2] & stations$lat <= lats_grids[3]) | (stations$lon >= lons_grids[5] & stations$lon <= lons_grids[6] & stations$lat >= lats_grids[3] & stations$lat <= lats_grids[4])) | (stations$lon >= lons_grids[1] & stations$lon <= lons_grids[2] & stations$lat >= lats_grids[4] & stations$lat <= lats_grids[5]) | (stations$lon >= lons_grids[2] & stations$lon <= lons_grids[3] & stations$lat >= lats_grids[5] & stations$lat <= lats_grids[6]), ]

index_sub3 = which(stations$stnid %in% stations3[,1])
write.csv(index_sub3, file = "../../data/processed/1d_results/sub3_index.csv", row.names = FALSE)

# subset 4
stations4 = stations[!((stations$lon >= lons_grids[4] & stations$lon <= lons_grids[5] & stations$lat >= lats_grids[1] & stations$lat <= lats_grids[2]) | (stations$lon >= lons_grids[5] & stations$lon <= lons_grids[6] & stations$lat >= lats_grids[2] & stations$lat <= lats_grids[3]) | (stations$lon >= lons_grids[1] & stations$lon <= lons_grids[2] & stations$lat >= lats_grids[3] & stations$lat <= lats_grids[4])) | (stations$lon >= lons_grids[2] & stations$lon <= lons_grids[3] & stations$lat >= lats_grids[4] & stations$lat <= lats_grids[5]) | (stations$lon >= lons_grids[3] & stations$lon <= lons_grids[4] & stations$lat >= lats_grids[5] & stations$lat <= lats_grids[6]), ]

index_sub4 = which(stations$stnid %in% stations4[,1])
write.csv(index_sub4, file = "../../data/processed/1d_results/sub4_index.csv", row.names = FALSE)

# subset 5
stations5 = stations[!((stations$lon >= lons_grids[5] & stations$lon <= lons_grids[6] & stations$lat >= lats_grids[1] & stations$lat <= lats_grids[2]) | (stations$lon >= lons_grids[1] & stations$lon <= lons_grids[2] & stations$lat >= lats_grids[2] & stations$lat <= lats_grids[3]) | (stations$lon >= lons_grids[2] & stations$lon <= lons_grids[3] & stations$lat >= lats_grids[3] & stations$lat <= lats_grids[4])) | (stations$lon >= lons_grids[3] & stations$lon <= lons_grids[4] & stations$lat >= lats_grids[4] & stations$lat <= lats_grids[5]) | (stations$lon >= lons_grids[4] & stations$lon <= lons_grids[5] & stations$lat >= lats_grids[5] & stations$lat <= lats_grids[6]), ]

index_sub5 = which(stations$stnid %in% stations5[,1])
write.csv(index_sub5, file = "../../data/processed/1d_results/sub5_index.csv", row.names = FALSE)
```

Functions for MAP and MCMC simulations

```{r}
#| label: MAP & MCMC
#| include: true

# MAP function
MAP_fit <- function(model, data){
  optim_result = NULL
  for (i in 1:25){
    optim_param = optimizing(model, data = data,
                             seed = sample.int(.Machine$integer.max, 1), 
                             init = "random",
                             check_data = TRUE, sample_file = NULL,
                             algorithm = c("LBFGS", "BFGS", "Newton"),
                             verbose = TRUE, hessian = FALSE, as_vector = TRUE,
                             draws = 0, constrained = TRUE, 
                             importance_resampling = TRUE, 
                             iter = 5000)
    if (optim_param$return_code == 0){
      optim_result = optim_param
      break
    }
  }
  return (optim_result)
}

# MCMC function
MCMC_fit <- function(model, data, init_list){
  fit = sampling(object = model, # Stan model (compiled)
                 data = data, # Data as a named list
                 iter = 5000, chains = 4, algorithm = "NUTS", 
                 init = list(init_list, init_list, init_list, init_list))
}
```

MAP and MCMC runs (5000 iterations 4 chains)

```{r}
index_i = index_sub3
stations_i = stations3

prcp_i = prcp[, index_i]
lons_i = stations_i[, 3]
lats_i = stations_i[, 2]
X_i = cbind(lons_i, lats_i)

prcp_i[112:122, ] = -99/25.4
```

```{r}
model_full = stan_model("Spatially-Varying-Covariate-Model.stan")
data_full = list(n_station = dim(prcp_i)[2],
                 n_obs = n_obs,
                 X = X_i,
                 y = prcp_i,
                 x = log_CO2)
model_full_MAP = MAP_fit(model_full, data_full)
init_list_model_full = as.list(model_full_MAP$par)
model_full_MCMC = MCMC_fit(model_full, data_full, init_list_model_full)
```

```{r}
file_path = "../../data/processed/1d_results/model_full_gridt1s3.Rds"
saveRDS(model_full_MCMC, file_path)
model_full_MCMC
```

Load previous results (if MCMC was done before)

```{r}
# Model_full_MCMC = readRDS("../../data/processed/1d_results/model_full_all_2rho.Rds") # all stations
# Model_full_MCMC
mcmc_trace(model_full_MCMC, pars = "mu_alpha")
```

Export MCMC results to be plotted in Julia

```{r}
extract_MCMC <- function(MCMC_posterior_all, variable, station_i){
  return (unlist(rstan::extract(MCMC_posterior_all, paste(variable, "[", station_i, "]", sep = ""))))
}
```

```{r}
variables_full = c("mu_rho", "mu_alpha", "logs_rho", "logs_alpha", "mu0_rho", "mu0_alpha", "logs0_rho", "logs0_alpha", "xi")
# variables_full = c("mu_rho", "mu_alpha", "logs_rho", "logs_alpha", "mu_w", "mu0_w", "logs_w", "logs0_w", "xi")
file_path_MCMC = "../../data/processed/1d_results/model_full_grids5.Rds"
model_full_MCMC_i = readRDS(file_path_MCMC)
n_s = dim(stations5)[1]
model_full_posterior = matrix(0, nrow = 10000, nc = 9+n_s*4)

for (v in 1:length(variables_full)){
  model_full_posterior[ , v] = unlist(rstan::extract(model_full_MCMC_i, paste(variables_full[v], sep = "")))
}
for (s in 1:n_s){
  model_full_posterior[ , length(variables_full)+s] = extract_MCMC(model_full_MCMC_i, "mu_beta", s)
}
for (s in 1:n_s){
  model_full_posterior[ , length(variables_full)+n_s+s] = extract_MCMC(model_full_MCMC_i, "logs_beta", s)
}
for (s in 1:n_s){
  model_full_posterior[ , length(variables_full)+n_s*2+s] = extract_MCMC(model_full_MCMC_i, "mu0", s)
}
for (s in 1:n_s){
  model_full_posterior[ , length(variables_full)+n_s*3+s] = extract_MCMC(model_full_MCMC_i, "logs0", s)
}

model_full_posterior = as.data.frame(model_full_posterior)
file_path = "../../data/processed/1d_results/model_full_grids5.csv"
write.csv(model_full_posterior, file_path)
```