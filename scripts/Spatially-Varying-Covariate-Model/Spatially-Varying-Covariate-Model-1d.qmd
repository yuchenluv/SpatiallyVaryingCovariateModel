---
title: "Spatially Varying Covariate Model"
format: html
---

Load the packages

```{r}
#| label: load-packages
#| include: false

# Run Stan code via R:
library(rstan)

# GEV distribution
library(evd)

# Detect cores for parallelization:
options(mc.cores = parallel::detectCores())

# Useful library for plotting:
library(bayesplot)
library(ggplot2)
```

Read precipitation and climate covariate data

```{r}
#| label: read raw data
#| include: false
data = read.csv("../../data/processed/raw_1d/GHCN_daily_30y.csv") # AMS data
stations = read.csv("../../data/processed/raw_1d/GHCN_stations_30y.csv") # station inventory

prcp = data[, 3:length(data)-1]
prcp[is.na(prcp)] <- -99 # change NA to negative values, could be detected in r stan
prcp = as.matrix(prcp/25.4) # mm to inches

n_station = dim(prcp)[2] # number of synthetic stations
n_obs = dim(prcp)[1] # number of years
lons = stations[, 3]
lats = stations[, 2]
X = cbind(lons, lats) # coordinates

log_CO2 = data[, length(data)] # CO2 covariate
```

Create the 5 subsets for cross-validation

```{r}
# random shuffle the station inventory
set.seed(42)
sequence = sample(nrow(stations))
stations_shuffled = stations[sequence, ]
prcp_shuffled = prcp[, sequence]
# 36, 36, 36, 36, 37

stations1 = stations_shuffled[-(1:36), ]
prcp1 = prcp_shuffled[, -(1:36)]
lons1 = stations1[, 3]
lats1 = stations1[, 2]
X1 = cbind(lons1, lats1)

stations2 = stations_shuffled[-(37:72), ]
prcp2 = prcp_shuffled[, -(37:72)]
lons2 = stations2[, 3]
lats2 = stations2[, 2]
X2 = cbind(lons2, lats2)

stations3 = stations_shuffled[-(73:108), ]
prcp3 = prcp_shuffled[, -(73:108)]
lons3 = stations3[, 3]
lats3 = stations3[, 2]
X3 = cbind(lons3, lats3)

stations4 = stations_shuffled[-(109:144), ]
prcp4 = prcp_shuffled[, -(109:144)]
lons4 = stations4[, 3]
lats4 = stations4[, 2]
X4 = cbind(lons4, lats4)

stations5 = stations_shuffled[-(145:181), ]
prcp5 = prcp_shuffled[, -(145:181)]
lons5 = stations5[, 3]
lats5 = stations5[, 2]
X5 = cbind(lons5, lats5)

# write.csv(stations_shuffled, "../../data/processed/raw_1d/stations_shuffled_30y.csv")
# write.csv(prcp_shuffled, "../../data/processed/raw_1d/prcp_shuffled_30y.csv")
```

Functions for MAP and MCMC simulations

```{r}
#| label: MAP & MCMC
#| include: true

# MAP function
MAP_fit <- function(model, data){
  optim_result = NULL
  for (i in 1:25){
    optim_param = optimizing(model, data = data,
                             seed = sample.int(.Machine$integer.max, 1), 
                             init = "random",
                             check_data = TRUE, sample_file = NULL,
                             algorithm = c("LBFGS", "BFGS", "Newton"),
                             verbose = TRUE, hessian = FALSE, as_vector = TRUE,
                             draws = 0, constrained = TRUE, 
                             importance_resampling = TRUE, 
                             iter = 5000)
    if (optim_param$return_code == 0){
      optim_result = optim_param
      break
    }
  }
  return (optim_result)
}

# MCMC function
MCMC_fit <- function(model, data, init_list){
  fit = sampling(object = model, # Stan model (compiled)
                 data = data, # Data as a named list
                 iter = 5000, chains = 4, algorithm = "NUTS", 
                 init = list(init_list, init_list, init_list, init_list))
}
```

MAP and MCMC runs (5000 iterations 4 chains)

```{r}
model_full = stan_model("Spatially-Varying-Covariate-Model.stan")
shuffled_index = c(1, 36, 37, 72, 73, 108, 109, 144, 145, 181, 1, 181) # simple way to get each subset data
for (i in 1:6){
  i_start = shuffled_index[i*2 - 1]
  i_end = shuffled_index[i*2]
  stations_i = stations_shuffled[-(i_start:i_end), ]
  prcp_i = prcp_shuffled[, -(i_start:i_end)]
  if (i == 6){
    stations_i = stations_shuffled
    prcp_i = prcp_shuffled
  }
  lons_i = stations_i[, 3]
  lats_i = stations_i[, 2]
  X_i = cbind(lons_i, lats_i)
  
  data_full = list(n_station = dim(prcp_i)[2],
                   n_obs = n_obs,
                   X = X_i,
                   y = prcp_i,
                   x = log_CO2)
  
  model_full_MAP = MAP_fit(model_full, data_full)
  init_list_model_full = as.list(model_full_MAP$par)
  model_full_MCMC = MCMC_fit(model_full, data_full, init_list_model_full)
  
  file_path = paste("../../data/processed/1d_results/model_full_", as.character(i), ".Rds", sep = "")
  saveRDS(model_full_MCMC, file_path)
}
```

```{r}
model_full = stan_model("Spatially-Varying-Covariate-Model.stan")
data_full = list(n_station = dim(prcp)[2],
                 n_obs = n_obs,
                 X = X,
                 y = prcp,
                 x = log_CO2)
model_full_MAP = MAP_fit(model_full, data_full)
init_list_model_full = as.list(model_full_MAP$par)
model_full_MCMC = MCMC_fit(model_full, data_full, init_list_model_full)
```

```{r}
file_path = "../../data/processed/1d_results/model_full_all_4rho.Rds"
saveRDS(model_full_MCMC, file_path)
model_full_MCMC
```

Load previous results (if MCMC was done before)

```{r}
# Model_full_MCMC = readRDS("../../data/processed/1d_results/model_full_all_2rho.Rds") # all stations
mcmc_trace(Model_full_MCMC, pars = "logs_w")
Model_full_MCMC
```

Export MCMC results to be plotted in Julia

```{r}
extract_MCMC <- function(MCMC_posterior_all, variable, station_i){
  return (unlist(rstan::extract(MCMC_posterior_all, paste(variable, "[", station_i, "]", sep = ""))))
}
```

```{r}
num_stations_subsets = c(145, 145, 145, 145, 144, 181)
variables_full = c("rho", "alpha", "mu_w", "logs_w", "mu0_w", "logs_w", "xi")
for (i in 1:1){
  file_path_MCMC = paste("../../data/processed/1d_results/model_full_grids", as.character(i), ".Rds", sep = "")
  model_full_MCMC_i = readRDS(file_path_MCMC)
  # n_s = num_stations_subsets[i]
  n_s = dim(prcp1)[2]
  model_full_posterior = matrix(0, nrow = 10000, nc = 7+n_s*4)

  for (v in 1:length(variables_full)){
    model_full_posterior[ , v] = unlist(rstan::extract(model_full_MCMC_i, paste(variables_full[v], sep = "")))
  }
  for (s in 1:n_s){
    model_full_posterior[ , length(variables_full)+s] = extract_MCMC(model_full_MCMC_i, "mu_beta", s)
  }
  for (s in 1:n_s){
    model_full_posterior[ , length(variables_full)+n_s+s] = extract_MCMC(model_full_MCMC_i, "logs_beta", s)
  }
  for (s in 1:n_s){
    model_full_posterior[ , length(variables_full)+n_s*2+s] = extract_MCMC(model_full_MCMC_i, "mu0", s)
  }
  for (s in 1:n_s){
    model_full_posterior[ , length(variables_full)+n_s*3+s] = extract_MCMC(model_full_MCMC_i, "logs0", s)
  }

  model_full_posterior = as.data.frame(model_full_posterior)
  file_path = paste("../../data/processed/1d_results/model_full_posterior_grids", as.character(i), ".csv", sep = "")
  write.csv(model_full_posterior, file_path)
}
```

```{r}
variables_full = c("mu_rho", "mu_alpha", "logs_rho", "logs_alpha", "mu0_rho", "mu0_alpha", "logs0_rho", "logs0_alpha", "xi")
# variables_full = c("mu_rho", "mu_alpha", "logs_rho", "logs_alpha", "mu_w", "mu0_w", "logs_w", "logs0_w", "xi")
file_path_MCMC = "../../data/processed/1d_results/model_full_all_4rho.Rds"
model_full_MCMC_i = readRDS(file_path_MCMC)
n_s = dim(prcp)[2]
model_full_posterior = matrix(0, nrow = 10000, nc = 9+n_s*4)

for (v in 1:length(variables_full)){
  model_full_posterior[ , v] = unlist(rstan::extract(model_full_MCMC_i, paste(variables_full[v], sep = "")))
}
for (s in 1:n_s){
  model_full_posterior[ , length(variables_full)+s] = extract_MCMC(model_full_MCMC_i, "mu_beta", s)
}
for (s in 1:n_s){
  model_full_posterior[ , length(variables_full)+n_s+s] = extract_MCMC(model_full_MCMC_i, "logs_beta", s)
}
for (s in 1:n_s){
  model_full_posterior[ , length(variables_full)+n_s*2+s] = extract_MCMC(model_full_MCMC_i, "mu0", s)
}
for (s in 1:n_s){
  model_full_posterior[ , length(variables_full)+n_s*3+s] = extract_MCMC(model_full_MCMC_i, "logs0", s)
}

model_full_posterior = as.data.frame(model_full_posterior)
file_path = "../../data/processed/1d_results/model_full_posterior_all_4rho.csv"
write.csv(model_full_posterior, file_path)
```