---
title: "plot results"
jupyter: julia-1.9
execute:
  cache: true
---

Mainly plotting results for using all the stations

# Setup

Load in packages

```{julia}
#| code-fold: true
using CairoMakie
using CSV
using DataFrames
using Distributions
using DrWatson
using GeoJSON
using GeoMakie
using HTTP
using Plots;
```

load commonly used functions

```{julia}
include("util.jl")
include("plot_util.jl")
```

# Load data

```{julia}
# all the raw data, including years, prcp and covariates
raw_data_all = DataFrame(CSV.File(datadir("processed/raw_1d/GHCN_daily_30y.csv")))

years = raw_data_all[:, 1]

# CO2 climate covariate
lnCO2 = DataFrame(CSV.File(datadir("processed/raw_1d/lnCO2.csv")))
lnCO2 = vcat(lnCO2[:, :log_CO2], log(525))
log_CO2 = lnCO2 .- mean(lnCO2[1:(length(lnCO2)-1)])
log_CO2_2022 = log_CO2[length(log_CO2)-1]
log_CO2_1940 = log_CO2[52]
log_CO2_2005 = log_CO2[117]

# raw precipiation intensity
# missing values as negative
# raw_data_all = coalesce.(raw_data_all, -99)
raw_prcp = raw_data_all[:, 2:size(raw_data_all)[2]-1]

# stations
raw_stations = DataFrame(CSV.File(datadir("processed/raw_1d/GHCN_stations_30y.csv")))

# total number of stations
n_stations = size(raw_stations)[1];
```

```{julia}
# get the number of observations for each station
obs_counts = [count(!ismissing, raw_prcp[!, col]) for col in names(raw_prcp)]
raw_stations.n_obs = obs_counts;
raw_data_df = raw_stations # substitute raw_data_df later
```

Some general variables

```{julia}
# number of MCMC simulations
n_sim = 10000
```

## Map of number of observations

```{julia}
# number of observations
p_n_obs = map_points(raw_stations, raw_stations[:, :n_obs], "observed years", (30, 120), :matter, "", (1000, 300))
# save(plotsdir("1d/raw_data_nobs_all.png"), p_n_obs)
```

# MCMC results (points)

## MCMC posterior results from R

### Pooled Stationary Model

```{julia}
mu_rho_s_all, mu_alpha_s_all, logs_rho_s_all, logs_alpha_s_all, xi_s_all, mu_s_all, logs_s_all = read_MCMC_results_S("processed/1d_results/pooled_stationary_posterior_all.csv", n_stations);
```

```{julia}
rl100_S_mean, rl100_S_std = rl_etimate_S(raw_stations, mu_s_all, logs_s_all, xi_s_all, 0.99);
```

### Nonpooled Nonstationary Model

```{julia}
mu0_N_all, logs0_N_all, xi_N_all, mu_beta_N_all, logs_beta_N_all = read_MCMC_results_N("processed/1d_results/model_N_all.csv", n_stations)
mu0_N_t1, logs0_N_t1, xi_N_t1, mu_beta_N_t1, logs_beta_N_t1 = read_MCMC_results_N("processed/1d_results/model_N_t1.csv", n_stations);
```

```{julia}
rl100_N_mean, rl100_N_std = rl_estimate_N(raw_stations, mu0_N_all, logs_beta_N_all, mu0_N_all, logs0_N_all, xi_N_all, log_CO2_2022, 0.99);
```

### Spatially Varying Covariate Model

```{julia}
mu_rho, mu_alpha, logs_rho, logs_alpha, mu0_rho, mu0_alpha, logs0_rho, logs0_alpha, xi_all, μ_beta_all, logσ_beta_all, μ0_all, logσ0_all = read_MCMC_results_full_diffRho("processed/1d_results/model_full_posterior_all_4rho.csv", n_stations)
# mu_rho_t1, mu_alpha_t1, logs_rho_t1, logs_alpha_t1, mu0_rho_t1, mu0_alpha_t1, logs0_rho_t1, logs0_alpha_t1, xi_t1, μ_beta_t1, logσ_beta_t1, μ0_t1, logσ0_t1 = read_MCMC_results_full_diffRho("processed/1d_results/model_full_posterior_all_4rho.csv", n_stations);
```

## validation: Quantiles (simulated stations and years)

```{julia}
# for using all data
non_missing_count = [count(!ismissing, col) for col in eachcol(raw_prcp)]
total_records = sum(non_missing_count)
k = sim_quantiles(raw_prcp, μ_beta_all, logσ_beta_all, μ0_all, logσ0_all, xi_all, log_CO2, total_records)
quantile_all_singlePlot = Plots.histogram(vec(k), bins = 30, legend = false, xlabel = "", ylabel = "frequency", normalize = :pdf, fill = true, color = :grey, fillalpha = 0.8, title = "")
hline!([1], color = :blue, linewidth = 3)
annotate!([0.95], [0.95], Plots.text("ideal", :right, 15, :blue))
# save(plotsdir("1d/quantiles_all_singlePlot.png"), quantile_all_singlePlot)
```

## quantile score (for the excluded years)

```{julia}
function calculate_quantile_score(obs, est_p, p)
    # p is non-exceedance probability
    qs = Array{Union{Float64,Missing}}(zeros(size(obs)[1], size(obs)[2]))
    for i = 1:size(obs)[1]
        for j = 1:size(obs)[2]
            if ismissing(obs[i, j]) || obs[i, j] < 0
                qs[i, j] = missing
            else
                if obs[i, j] - est_p[i, j] >= 0
                    qs[i, j] = p * (obs[i, j] - est_p[i, j])
                else
                    qs[i, j] = (p - 1) * (obs[i, j] - est_p[i, j])
                end
            end
        end
    end
    return sum(skipmissing(qs)) / count(!ismissing, qs)
end
```

for the full model

```{julia}
obs = raw_prcp ./ 25.4
p_all = [0.9, 0.98, 0.99]

rl_p_full(p) = hcat([rl_estimate_full(raw_stations, μ_beta_all, logσ_beta_all, μ0_all, logσ0_all, xi_all, c, p)[1] for c in log_CO2]...)'
[calculate_quantile_score(obs, rl_p_full(p), p) for p in p_all]
```

for the pooled stationary model

```{julia}
rl_p_S(p) = hcat([rl_etimate_S(raw_stations, mu_s_all, logs_s_all, xi_s_all, p)[1] for _ in log_CO2]...)'
[calculate_quantile_score(obs, rl_p_S(p), p) for p in p_all]
```

for the nonpooled nonstationary model

```{julia}
rl_p_N(p) = hcat([rl_estimate_N(raw_stations, mu_beta_all_non, logs_beta_all_non, mu0_all_non, logs0_all_non, xi_all_non, c, p)[1] for c in log_CO2]...)'
[calculate_quantile_score(obs, rl_p_N(p), p) for p in p_all]
```

## trends in points

```{julia}
mean_stations_10_all_1940, std_stations_10_all_1940 = rl_estimate_full(raw_stations, μ_beta_all, logσ_beta_all, μ0_all, logσ0_all, xi_all, log_CO2_1940, 0.9)
mean_stations_50_all_1940, std_stations_50_all_1940 = rl_estimate_full(raw_stations, μ_beta_all, logσ_beta_all, μ0_all, logσ0_all, xi_all, log_CO2_1940, 0.98)
mean_stations_100_all_1940, std_stations_100_all_1940 = rl_estimate_full(raw_stations, μ_beta_all, logσ_beta_all, μ0_all, logσ0_all, xi_all, log_CO2_1940, 0.99)

mean_stations_10_all_2022, std_stations_10_all_2022 = rl_estimate_full(raw_stations, μ_beta_all, logσ_beta_all, μ0_all, logσ0_all, xi_all, log_CO2_2022, 0.9)
mean_stations_50_all_2022, std_stations_50_all_2022 = rl_estimate_full(raw_stations, μ_beta_all, logσ_beta_all, μ0_all, logσ0_all, xi_all, log_CO2_2022, 0.98)
mean_stations_100_all_2022, std_stations_100_all_2022 = rl_estimate_full(raw_stations, μ_beta_all, logσ_beta_all, μ0_all, logσ0_all, xi_all, log_CO2_2022, 0.99)
```

```{julia}
trend_df = [mean_stations_10_all_2022, mean_stations_50_all_2022, mean_stations_100_all_2022, mean_stations_10_all_1940, mean_stations_50_all_1940, mean_stations_100_all_1940, (mean_stations_10_all_2022 .- mean_stations_10_all_1940) ./ mean_stations_10_all_1940 .* 100, (mean_stations_50_all_2022 .- mean_stations_50_all_1940) ./ mean_stations_50_all_1940 .* 100, (mean_stations_100_all_2022 .- mean_stations_100_all_1940) ./ mean_stations_100_all_1940 .* 100]

rows = [1, 1, 1, 2, 2, 2, 3, 3, 3]
cols = [1, 2, 3, 1, 2, 3, 1, 2, 3]
res = (2000, 700)
row_hs = [400, 375, 375]
row_names = ["2022", "", "", "1940", "", "", "2022-1940", "", ""]
title_names = ["10 year", "50 year", "100 year", "", "", "", "", "", ""]
bar_names = ["", "", "inches/d", "", "", "inches/d", "", "", "%"]
ranges = [(5, 16), (5, 16), (5, 16), (5, 16), (5, 16), (5, 16), (15, 30), (15, 30), (15, 30)]
colors = [:roma25, :roma25, :roma25, :roma25, :roma25, :roma25, :BuPu, :BuPu, :BuPu]
p_trend_points = map_points_subplots(raw_stations, trend_df, colors, rows, cols, row_names, res, row_hs, title_names, ranges; diff_coord = false, bar_all = false, diff_colscheme = true, bar_name = bar_names)
save(plotsdir("1d/p_trend_points.png"), p_trend_points)
```

## model comparison

### nonstationary coefficients map

```{julia}
μ_beta_mean = mean.(eachcol(μ_beta_all))
logσ_beta_mean = mean.(eachcol(logσ_beta_all))
μ_beta_N_mean = mean.(eachcol(mu_beta_N_all))
logσ_beta_N_mean = mean.(eachcol(logs_beta_N_all))
coefficients_results = [μ_beta_N_mean, μ_beta_mean, logσ_beta_N_mean, logσ_beta_mean]

rows = [1, 1, 2, 2]
cols = [1, 3, 1, 3]
res = (1500, 500)
row_hs = [900, 900]
col_names = [" ", " ", " ", " "]
row_names = ["location", "", "scale", ""]
title_names = ["Nonpooled Nonstationary Model", "Spatially Varying Covariate Model", "", ""]
ranges = [(-1, 1) .* maximum(abs.([maximum(μ_beta_N_mean), minimum(μ_beta_N_mean)])), (minimum(μ_beta_mean), maximum(μ_beta_mean)), (-1, 1) .* maximum(abs.([maximum(logσ_beta_N_mean), minimum(logσ_beta_N_mean)])), (minimum(logσ_beta_mean), maximum(logσ_beta_mean))]

p_coefficients = map_points_subplots(raw_stations, coefficients_results, [:PuOr, :BuPu, :PuOr, :BuPu], rows, cols, row_names, res, row_hs, title_names, ranges; diff_coord = false, bar_all = true, diff_colscheme = true)

save(plotsdir("1d/p_coefficients.png"), p_coefficients)
```

### point return level estimates

```{julia}
mean_stations_full = [rl_estimate_full(raw_stations, μ_beta_all, logσ_beta_all, μ0_all, logσ0_all, xi_all, log_CO2_2022, p)[1] for p in [0.9, 0.98, 0.99]]
std_stations_full = [rl_estimate_full(raw_stations, μ_beta_all, logσ_beta_all, μ0_all, logσ0_all, xi_all, log_CO2_2022, p)[2] for p in [0.9, 0.98, 0.99]]

mean_stations_S = [rl_etimate_S(raw_stations, mu_s_all, logs_s_all, xi_s_all, p)[1] for p in [0.9, 0.98, 0.99]]
std_stations_S = [rl_etimate_S(raw_stations, mu_s_all, logs_s_all, xi_s_all, p)[2] for p in [0.9, 0.98, 0.99]]

mean_stations_N = [rl_estimate_N(raw_stations, mu_beta_N_all, logs_beta_N_all, mu0_N_all, logs0_N_all, xi_N_all, log_CO2_2022, p)[1] for p in [0.9, 0.98, 0.99]]
std_stations_N = [rl_estimate_N(raw_stations, mu_beta_N_all, logs_beta_N_all, mu0_N_all, logs0_N_all, xi_N_all, log_CO2_2022, p)[2] for p in [0.9, 0.98, 0.99]]

rl_results_mean = vcat(mean_stations_S, mean_stations_N, mean_stations_full)
rl_results_std = vcat(std_stations_S, std_stations_N, std_stations_full)

rows = [1, 2, 3, 1, 2, 3, 1, 2, 3]
cols = [1, 1, 1, 2, 2, 2, 3, 3, 3]
res = (2000, 700)
row_hs = [400, 375, 375]
row_names = ["10 year", "50 year", "100 year", "", "", "", "", "", ""]
title_names = ["Pooled Stationary Model", "", "", "Nonpooled Nonstationary Model", "", "", "Spatially Varying Covariate Model", "", ""]

ranges_mean = [(6, 9), (9, 13), (10, 16.5), (6, 9), (9, 13), (10, 16.5), (6, 9), (9, 13), (10, 16.5)]

ranges_std = [(0, 1), (0, 2), (0, 3), (0, 1), (0, 2), (0, 3), (0, 1), (0, 2), (0, 3)]

p_rl_points_mean = map_points_subplots(raw_stations, rl_results_mean, :roma25, rows, cols, row_names, res, row_hs, title_names, ranges_mean; diff_coord = false, bar_all = false, diff_colscheme = false)

p_rl_points_std = map_points_subplots(raw_stations, rl_results_std, :GnBu, rows, cols, row_names, res, row_hs, title_names, ranges_std; diff_coord = false, bar_all = false, diff_colscheme = false)

# save(plotsdir("1d/model_comparison_rlmean.png"), p_rl_points_mean)
# save(plotsdir("1d/model_comparison_rlstd.png"), p_rl_points_std)
```

## compare with Atlas 14

Atlas 14 estimates

```{julia}
# 15min, 1h, 6h, 1d
rows = [3, 5, 8, 10]
# 2y, 5y, 10y, 25y, 50y, 100y
cols = [2, 3, 4, 5, 6, 7]

# Atlas14_rl10_1d = [get_Atlas14(string(raw_stations[!, :lat][i]), string(raw_stations[!, :lon][i]), 10, 4) for i in 1:length(raw_stations[!, :lat])]
# Atlas14_rl50_1d = [get_Atlas14(string(raw_stations[!, :lat][i]), string(raw_stations[!, :lon][i]), 10, 6) for i in 1:length(raw_stations[!, :lat])]
# Atlas14_rl100_1d = [get_Atlas14(string(raw_stations[!, :lat][i]), string(raw_stations[!, :lon][i]), 10, 7) for i in 1:length(raw_data_df[!, :lat])]

# df_Altas14 = DataFrame(Atlas14_10y1d=Atlas14_rl10_1d, Atlas14_50y1d=Atlas14_rl50_1d, Atlas14_100y1d=Atlas14_rl100_1d)
# CSV.write(datadir("processed/1d_results/Atlas14_1d.csv"), df_Altas14)

df_Altas14 = DataFrame(CSV.File(datadir("processed/1d_results/Atlas14_1d.csv")))
Atlas14_rl10_1d = df_Altas14[:, 1]
Atlas14_rl50_1d = df_Altas14[:, 2]
Atlas14_rl100_1d = df_Altas14[:, 3]
```

### map of Atlas 14 comparison

```{julia}
Atlas14_comparison = [
    (mean_stations_S[1] .- Atlas14_rl10_1d) ./ Atlas14_rl10_1d .* 100,
    (mean_stations_N[1] .- Atlas14_rl10_1d) ./ Atlas14_rl10_1d .* 100,
    (mean_stations_full[1] .- Atlas14_rl10_1d) ./ Atlas14_rl10_1d .* 100,
    (mean_stations_S[2] .- Atlas14_rl50_1d) ./ Atlas14_rl50_1d .* 100,
    (mean_stations_N[2] .- Atlas14_rl50_1d) ./ Atlas14_rl50_1d .* 100,
    (mean_stations_full[2] .- Atlas14_rl50_1d) ./ Atlas14_rl50_1d .* 100,
    (mean_stations_S[3] .- Atlas14_rl100_1d) ./ Atlas14_rl100_1d .* 100,
    (mean_stations_N[3] .- Atlas14_rl100_1d) ./ Atlas14_rl100_1d .* 100,
    (mean_stations_full[3] .- Atlas14_rl100_1d) ./ Atlas14_rl100_1d .* 100,
]

rows = [1, 1, 1, 2, 2, 2, 3, 3, 3]
cols = [1, 2, 3, 1, 2, 3, 1, 2, 3]
res = (2000, 700)
row_hs = [400, 375, 375]
row_names = ["10 year", "", "", "50 year", "", "", "100 year", "", ""]
title_names = ["pooled stationary", "nonpooled nonstationary", "pooled nonstationary", "", "", "", "", "", ""]

ranges = fill((-30, 30), length(Atlas14_comparison))

p_Atlas14_diff = map_points_subplots(raw_stations, Atlas14_comparison, :RdBu, rows, cols, row_names, res, row_hs, title_names, ranges; diff_coord = false, bar_all = false, diff_colscheme = false)

save(plotsdir("1d/Atlas14_comparison.png"), p_Atlas14_diff)
```

### time series of Atlas 14 comparison

```{julia}
# Houston, 29.7914, -95.4261, 121
# New Orleans, 29.9167, -90.1303, 168
# Galveston, 29.2703, -94.8642, 167
# Mobile, 30.6833, -88.0333, 5
# mu_rho, mu_alpha, logs_rho, logs_alpha, mu0_rho, mu0_alpha, logs0_rho, logs0_alpha, xi_all, μ_beta_all, logσ_beta_all, μ0_all, logσ0_all
index_cities = [121, 168, 167, 5]

# time series of the GEV distributions
ts_dist_Hou = [get_dist_MCMC_full(index_cities[1], μ_beta_all, logσ_beta_all, μ0_all, logσ0_all, xi_all, x, ) for x in log_CO2]
ts_dist_NOLA = [get_dist_MCMC_full(index_cities[2], μ_beta_all, logσ_beta_all, μ0_all, logσ0_all, xi_all, x) for x in log_CO2]
ts_dist_Gal = [get_dist_MCMC_full(index_cities[3], μ_beta_all, logσ_beta_all, μ0_all, logσ0_all, xi_all, x) for x in log_CO2]
ts_dist_Mob = [get_dist_MCMC_full(index_cities[4], μ_beta_all, logσ_beta_all, μ0_all, logσ0_all, xi_all, x) for x in log_CO2]

p_Hou = plot_time_series(vcat(years, 2050), "Houston, TX", ts_dist_Hou; x_label = "", y_label = "100 year return level [inches/d]", Atlas14 = Atlas14_rl100_1d[index_cities[1]])
p_NOLA = plot_time_series(vcat(years, 2050), "New Orleans, LA", ts_dist_NOLA; x_label = "", y_label = " ", Atlas14 = Atlas14_rl100_1d[index_cities[2]])
p_Gal = plot_time_series(vcat(years, 2050), "Galveston, TX", ts_dist_Gal; x_label = "Year", y_label = "100 year return level [inches/d]", Atlas14 = Atlas14_rl100_1d[index_cities[3]])
p_Mob = plot_time_series(vcat(years, 2050), "Mobile, AL", ts_dist_Mob; x_label = "Year", y_label = " ", Atlas14 = Atlas14_rl100_1d[index_cities[4]])
```

```{julia}
layout = @layout [
    a a
    a a
]

p_ts_cities = Plots.plot(
    p_Hou,
    p_NOLA,
    p_Gal,
    p_Mob,
    layout = layout,
    size = (1500, 1000)
)

Plots.plot!(p_ts_cities, left_margin = 10Plots.mm, bottom_margin = 5Plots.mm)

save(plotsdir("1d/p_ts_cities.png"), p_ts_cities)
```

## Single location return level estimate

```{julia}
cities_names = ["Houston, TX", "New Orleans, LA", "Galveston, TX", "Mobile, AL"]
coords_cities = [[-95.4261, 29.7914], [-90.1303, 29.9167], [-94.8642, 29.2703], [-88.0333, 30.6833]]
index_cities = [121, 168, 167, 5]
# Houston, 29.7914, -95.4261, 121
# New Orleans, 29.9167, -90.1303, 168
# Galveston, 29.2703, -94.8642, 167
# Mobile, 30.6833, -88.0333, 5

Atlas_14_Hou = get_Atlas14_IDF(string(coords[1][2]), string(coords[1][1]))
Atlas_14_NOLA = get_Atlas14_IDF(string(coords[2][2]), string(coords[2][1]))
Atlas_14_Gal = get_Atlas14_IDF(string(coords[3][2]), string(coords[3][1]))
Atlas_14_Mob = get_Atlas14_IDF(string(coords[4][2]), string(coords[4][1]))

dist_Hou_S = get_dist_MCMC_S(index_cities[1], mu_s_all, logs_s_all, xi_s_all)
dist_NOLA_S = get_dist_MCMC_S(index_cities[2], mu_s_all, logs_s_all, xi_s_all)
dist_Gal_S = get_dist_MCMC_S(index_cities[3], mu_s_all, logs_s_all, xi_s_all)
dist_Mob_S = get_dist_MCMC_S(index_cities[4], mu_s_all, logs_s_all, xi_s_all)

p_rl_Hou_S = plot_return_period(Atlas_14_Hou, "Pooled Stationary Model", (0, 25), dist_Hou_S, lengend_loc=:topleft, x_label="", y_label=cities_names[1])
p_rl_NOLA_S = plot_return_period(Atlas_14_NOLA, "", (0, 25), dist_NOLA_S, lengend_loc=false, x_label="", y_label=cities_names[2])
p_rl_Gal_S = plot_return_period(Atlas_14_Gal, "", (0, 25), dist_Gal_S, lengend_loc=false, x_label="", y_label=cities_names[3])
p_rl_Mob_S = plot_return_period(Atlas_14_Mob, "", (0, 25), dist_Mob_S, lengend_loc=false, x_label="", y_label=cities_names[4])

dist_Hou_N = get_dist_MCMC_N(index_cities[1], mu_beta_N_all, logs_beta_N_all, mu0_N_all, logs0_N_all, xi_N_all, log_CO2_2022)
dist_NOLA_N = get_dist_MCMC_N(index_cities[2], mu_beta_N_all, logs_beta_N_all, mu0_N_all, logs0_N_all, xi_N_all, log_CO2_2022)
dist_Gal_N = get_dist_MCMC_N(index_cities[3], mu_beta_N_all, logs_beta_N_all, mu0_N_all, logs0_N_all, xi_N_all, log_CO2_2022)
dist_Mob_N = get_dist_MCMC_N(index_cities[4], mu_beta_N_all, logs_beta_N_all, mu0_N_all, logs0_N_all, xi_N_all, log_CO2_2022)
p_rl_Hou_N = plot_return_period(Atlas_14_Hou, "Nonpooled Nonstationary Model", (0, 50), dist_Hou_N, lengend_loc=false, x_label="", y_label="")
p_rl_NOLA_N = plot_return_period(Atlas_14_NOLA, "", (0, 50), dist_NOLA_N, lengend_loc=false, x_label="", y_label="")
p_rl_Gal_N = plot_return_period(Atlas_14_Gal, "", (0, 50), dist_Gal_N, lengend_loc=false, x_label="", y_label="")
p_rl_Mob_N = plot_return_period(Atlas_14_Mob, "", (0, 50), dist_Mob_N, lengend_loc=false, x_label="", y_label="")

dist_Hou_full = get_dist_MCMC_full(index_cities[1], μ_beta_all, logσ_beta_all, μ0_all, logσ0_all, xi_all, log_CO2_2022)
dist_NOLA_full = get_dist_MCMC_full(index_cities[2], μ_beta_all, logσ_beta_all, μ0_all, logσ0_all, xi_all, log_CO2_2022)
dist_Gal_full = get_dist_MCMC_full(index_cities[3], μ_beta_all, logσ_beta_all, μ0_all, logσ0_all, xi_all, log_CO2_2022)
dist_Mob_full = get_dist_MCMC_full(index_cities[4], μ_beta_all, logσ_beta_all, μ0_all, logσ0_all, xi_all, log_CO2_2022)
p_rl_Hou_full = plot_return_period(Atlas_14_Hou, "Spatially Varying Covariate Model", (0, 25), dist_Hou_full, lengend_loc = false, x_label = "", y_label = "")
p_rl_NOLA_full = plot_return_period(Atlas_14_NOLA, "", (0, 25), dist_NOLA_full, lengend_loc = false, x_label = "", y_label = "")
p_rl_Gal_full = plot_return_period(Atlas_14_Gal, "", (0, 25), dist_Gal_full, lengend_loc = false, x_label = "", y_label = "")
p_rl_Mob_full = plot_return_period(Atlas_14_Mob, "", (0, 25), dist_Mob_full, lengend_loc = false, x_label = "", y_label = "")
```

```{julia}
layout = @layout [
    a a a
    a a a
    a a a
    a a a
]
p_rl_stations = Plots.plot(
    p_rl_Hou_S, p_rl_Hou_N, p_rl_Hou_full,
    p_rl_NOLA_S, p_rl_NOLA_N, p_rl_NOLA_full, 
    p_rl_Gal_N, p_rl_Gal_N, p_rl_Gal_full, 
    p_rl_Mob_N, p_rl_Mob_N, p_rl_Mob_full, 
    layout = layout,
    size = (1800, 1500),
)
Plots.plot!(p_rl_stations, left_margin = 10Plots.mm, bottom_margin = 10Plots.mm)

# save(plotsdir("1d/p_rl_stations.png"), p_rl_stations)
```

## gridded MCMC results

Generate a set of new points

```{julia}
# resoluation of 1km * 1km
# lons_transformed = range(minimum(point_df[!, :lon]), maximum(point_df[!, :lon]), length=1175)
# lats_transformed = range(minimum(point_df[!, :lat]), maximum(point_df[!, :lat]), length=276)

n_lons = 100
n_lats = 60
lons_transformed = range(minimum(raw_data_df[!, :lon]), maximum(raw_data_df[!, :lon]), length=n_lons) # 100
lats_transformed = range(minimum(raw_data_df[!, :lat]), maximum(raw_data_df[!, :lat]), length=n_lats) # 60

X_transformed = [[lon, lat] for lon in lons_transformed, lat in lats_transformed]
lons_new_vec = vec([vector[1] for vector in X_transformed])
lats_new_vec = vec([vector[2] for vector in X_transformed])

# X_old = [[lon, lat] for (lon, lat) in zip(raw_stations[!, :lon], raw_stations[!, :lat])]
X_old = Matrix(raw_stations[:, 2:3])'
```

Function to filter inland grids

```{julia}
function check_inland(coord)
    mask = GeoDatasets.LandSeaMask()
    if GeoDatasets.is_land(mask, coord[2], coord[1])
        return true
    else
        return false
    end
end
```

Interpolation with GP parameters

```{julia}
gev_dist_interp(i, x) = GP_dist(mu_rho[i], mu_alpha[i], logs_rho[i], logs_alpha[i], mu0_rho[i], mu0_alpha[i], logs0_rho[i], logs0_alpha[i], xi_all[i], collect(μ_beta_all[i, :]), collect(logσ_beta_all[i, :]), collect(μ0_all[i, :]), collect(logσ0_all[i, :]), X_old, lons_new_vec, lats_new_vec, x)

gev_dist_interp_matrix(x, n_sim) = hcat([gev_dist_interp(i, x) for i in 1:n_sim]...)
rl_interp_matrix(gev_dist_interp, p) = reshape(vec(mean(quantile.(gev_dist_interp, p), dims=2)), (n_lons, n_lats))

gev_dist_interp_2022 = gev_dist_interp_matrix(log_CO2_2022, 10000)
rl100_interp_2022 = Matrix{Union{Float64,Missing}}(rl_interp_matrix(gev_dist_interp_2022, 0.99))
# rl50_interp_2022 = Matrix{Union{Float64,Missing}}(rl_interp_matrix(gev_dist_interp_2022, 0.98))
# rl10_interp_2022 = Matrix{Union{Float64,Missing}}(rl_interp_matrix(gev_dist_interp_2022, 0.9))

gev_dist_interp_1940 = gev_dist_interp_matrix(log_CO2_1940, 10000)
rl100_interp_1940 = Matrix{Union{Float64,Missing}}(rl_interp_matrix(gev_dist_interp_1940, 0.99))
# rl50_interp_1940 = Matrix{Union{Float64,Missing}}(rl_interp_matrix(gev_dist_interp_1940, 0.98))
# rl10_interp_1940 = Matrix{Union{Float64,Missing}}(rl_interp_matrix(gev_dist_interp_1940, 0.9))

rl100_interp_change = Matrix{Union{Float64,Missing}}((rl100_interp_2022 .- rl100_interp_1940) ./ rl100_interp_1940 .* 100)
# rl50_interp_change = Matrix{Union{Float64,Missing}}((rl50_interp_2022 .- rl50_interp_1940) ./ rl50_interp_1940 .* 100)
# rl10_interp_change = Matrix{Union{Float64,Missing}}((rl10_interp_2022 .- rl10_interp_1940) ./ rl10_interp_1940 .* 100)
```

check in-land

```{julia}
for i in 1:n_lons
    for j in 1:n_lats
        if check_inland(X_transformed[i, j])
            nothing
        else
            rl100_interp_2022[i, j] = missing
            rl10_interp_2022[i, j] = missing
            rl100_interp_change[i, j] = missing
            rl10_interp_change[i, j] = missing
        end
    end
end
```

```{julia}
var_transformed_all = [rl10_interp_2022, rl100_interp_2022, rl10_interp_change, rl100_interp_change]

res = (1500, 500)
row_hs = [900, 900]

rows = [1, 1, 2, 2]
cols = [1, 2, 1, 2]

row_names = ["2022", "", "2022-1940", ""]
col_names = [" ", " ", " ", " "]
title_names = ["10 year", "100 year", "", ""]
bar_name = ["", "inches/d", "", "% difference"]

colors = [:roma10, :roma10, :YlGn_6, :YlGn_6]

ranges = [(6, 16), (6, 16), (15, 28), (15, 28)]

gridded_rl_change = map_grids_subplots(raw_data_df, lons_transformed, lats_transformed, var_transformed_all, colors, rows, cols, row_names, col_names, res, row_hs, title_names, ranges; diff_coord=false, bar_all=false, diff_colbar=true, bar_name=bar_name)

# save(plotsdir("1d/gridded_rl_change.png"), gridded_rl_change)
```
